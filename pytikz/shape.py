import numpy as np
from .abstract import Drawable
from .vector import Transformable, Vector, VectorType
from abc import ABC, abstractmethod


class Shape(ABC):
    @abstractmethod
    def __str__(self):
        pass


class ClosedShape(Shape, ABC):
    pass


class StyledShape(Drawable, Transformable):
    def __init__(self, shape, shape_style):
        self.shape = shape
        self.shape_style = shape_style

    def __str__(self):
        """Returns the string representation of the shape generated by the drawer."""
        return self.shape_style.draw(self.shape)

    def apply(self, transformation):
        """Returns itself with the transformation applied to .shape."""
        self.shape.apply(transformation)

    def copy(self):
        """Returns the same DrawableShape except that .shape is copied."""
        return StyledShape(self.shape.copy(), self.shape_style)


class ShapeStyle:
    line = True
    line_color = None
    line_width = None
    line_join = None

    fill = False
    fill_color = None

    def __call__(self, shape):
        return StyledShape(shape, self)

    def draw(self, shape):
        if self.fill:
            assert isinstance(shape, ClosedShape)

        if not self.line:
            if self.fill:
                return f"\\fill[{self.fill_color}] {shape};"
            if not self.fill:
                return ""

        if self.line:

            options = []
            if self.line_color:
                options.append(self.line_color)
            if self.line_width:
                options.append(self.line_width.value)
            if self.line_join:
                options.append(f"line join={self.line_join.value}")
            if self.fill:
                options.append(f"fill={self.fill_color}")
            options = f"[{', '.join(options)}]" if options else ""

            return f"\\draw{options} {shape};"


class Path(Shape, Transformable):
    def __init__(self, data):
        self._list = data

    def __str__(self):
        return " -- ".join(str(v) for v in self._list)

    def apply(self, transformation):
        self._list = [transformation(v) for v in self._list]

    def copy(self):
        return Path(self._list)


class ClosedPath(Path, ClosedShape):
    def __str__(self):
        return super().__str__() + " -- cycle"


class Rectangle(ClosedPath):
    def __init__(self, left, right, lower, upper):
        self._list = [
            Vector(left, lower),
            Vector(left, upper),
            Vector(right, upper),
            Vector(right, lower),
        ]


class Circle(ClosedShape):
    def __init__(self, center, radius):
        self.center = center
        self.radius = radius

    def __str__(self):
        return f"{str(self.center)} circle ({self.radius})"

    def apply(self, transformation):
        self.center = transformation(self.center)

    def copy(self):
        return Circle(self.center, self.radius)
